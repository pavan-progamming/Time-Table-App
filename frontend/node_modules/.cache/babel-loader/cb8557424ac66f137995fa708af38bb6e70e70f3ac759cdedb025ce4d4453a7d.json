{"ast":null,"code":"import { LocalNotifications } from '@capacitor/local-notifications';\nclass NotificationService {\n  async requestPermissions() {\n    try {\n      // Create high-priority channel for Android (the \"Bell\")\n      await LocalNotifications.createChannel({\n        id: 'class-reminders',\n        name: 'Class Reminders',\n        description: 'Notifications for upcoming classes',\n        importance: 5,\n        // Important for \"ringing\" sound\n        visibility: 1,\n        sound: 'bell.wav',\n        // Even if file doesn't exist, importance 5 forces high sound\n        vibration: true\n      });\n      const {\n        display\n      } = await LocalNotifications.requestPermissions();\n      return display === 'granted';\n    } catch (e) {\n      console.error('Permission request failed', e);\n      return false;\n    }\n  }\n  async scheduleClassReminders(timetable, userName = 'Pavan') {\n    try {\n      // First clear all existing notifications to avoid duplicates\n      const pending = await LocalNotifications.getPending();\n      if (pending.notifications.length > 0) {\n        await LocalNotifications.cancel(pending);\n      }\n      const schedule = [];\n      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      const todayIndex = new Date().getDay();\n      timetable.forEach(item => {\n        if (item.is_completed) return;\n        const [hours, minutes] = item.start_time.split(':').map(Number);\n        const itemDayIndex = days.indexOf(item.day);\n        const repeatConfig = typeof item.repeat_config === 'string' ? JSON.parse(item.repeat_config) : item.repeat_config || {\n          type: 'None'\n        };\n        if (itemDayIndex === -1 && repeatConfig.type !== 'Daily') return;\n        const now = new Date();\n        let notificationDate = new Date();\n        notificationDate.setHours(hours, minutes, 0, 0);\n\n        // Apply alert offset (e.g. 5 mins before)\n        const offsetMinutes = item.alert_offset || 0;\n        notificationDate.setMinutes(notificationDate.getMinutes() - offsetMinutes);\n\n        // Personalize body based on user request: \"pavan its 2pm it's time do dsa\"\n        const ampm = hours >= 12 ? 'pm' : 'am';\n        const displayHour = hours % 12 || 12;\n        const timeString = `${displayHour}${ampm}`;\n        const body = `${userName}, it's ${timeString}! It's time to do ${item.subject}.`;\n        if (repeatConfig.type === 'Daily') {\n          // Daily notification\n          if (notificationDate < now) {\n            notificationDate.setDate(notificationDate.getDate() + 1);\n          }\n          schedule.push({\n            title: `⏰ Time for ${item.subject}`,\n            body: body,\n            id: Math.floor(Math.random() * 1000000),\n            schedule: {\n              on: {\n                hour: hours,\n                minute: Math.max(0, minutes - offsetMinutes)\n              },\n              repeats: true,\n              allowWhileIdle: true\n            },\n            sound: 'default',\n            channelId: 'class-reminders',\n            extra: {\n              type: 'class_reminder'\n            }\n          });\n        } else {\n          // Weekly or One-time\n          let daysAway = itemDayIndex - todayIndex;\n          if (daysAway < 0) daysAway += 7;\n          notificationDate.setDate(now.getDate() + daysAway);\n          if (notificationDate < now) {\n            notificationDate.setDate(notificationDate.getDate() + 7);\n          }\n          schedule.push({\n            title: `⏰ Time for ${item.subject}`,\n            body: body,\n            id: Math.floor(Math.random() * 1000000),\n            schedule: {\n              at: notificationDate,\n              repeats: repeatConfig.type === 'Weekly',\n              every: repeatConfig.type === 'Weekly' ? 'week' : undefined,\n              allowWhileIdle: true\n            },\n            sound: 'default',\n            channelId: 'class-reminders',\n            extra: {\n              type: 'class_reminder'\n            }\n          });\n        }\n      });\n      if (schedule.length > 0) {\n        // Ensure unique IDs\n        const uniqueSchedule = schedule.map((s, idx) => ({\n          ...s,\n          id: idx + 100\n        }));\n        await LocalNotifications.schedule({\n          notifications: uniqueSchedule.slice(0, 50)\n        });\n      }\n    } catch (error) {\n      console.error('Failed to schedule notifications:', error);\n    }\n  }\n  async notifyImmediately(title, body) {\n    await LocalNotifications.schedule({\n      notifications: [{\n        title,\n        body,\n        id: 1,\n        schedule: {\n          at: new Date(Date.now() + 1000)\n        },\n        sound: 'default'\n      }]\n    });\n  }\n}\nexport default new NotificationService();","map":{"version":3,"names":["LocalNotifications","NotificationService","requestPermissions","createChannel","id","name","description","importance","visibility","sound","vibration","display","e","console","error","scheduleClassReminders","timetable","userName","pending","getPending","notifications","length","cancel","schedule","days","todayIndex","Date","getDay","forEach","item","is_completed","hours","minutes","start_time","split","map","Number","itemDayIndex","indexOf","day","repeatConfig","repeat_config","JSON","parse","type","now","notificationDate","setHours","offsetMinutes","alert_offset","setMinutes","getMinutes","ampm","displayHour","timeString","body","subject","setDate","getDate","push","title","Math","floor","random","on","hour","minute","max","repeats","allowWhileIdle","channelId","extra","daysAway","at","every","undefined","uniqueSchedule","s","idx","slice","notifyImmediately"],"sources":["D:/time table/frontend/src/services/NotificationService.js"],"sourcesContent":["import { LocalNotifications } from '@capacitor/local-notifications';\r\n\r\nclass NotificationService {\r\n    async requestPermissions() {\r\n        try {\r\n            // Create high-priority channel for Android (the \"Bell\")\r\n            await LocalNotifications.createChannel({\r\n                id: 'class-reminders',\r\n                name: 'Class Reminders',\r\n                description: 'Notifications for upcoming classes',\r\n                importance: 5, // Important for \"ringing\" sound\r\n                visibility: 1,\r\n                sound: 'bell.wav', // Even if file doesn't exist, importance 5 forces high sound\r\n                vibration: true\r\n            });\r\n\r\n            const { display } = await LocalNotifications.requestPermissions();\r\n            return display === 'granted';\r\n        } catch (e) {\r\n            console.error('Permission request failed', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async scheduleClassReminders(timetable, userName = 'Pavan') {\r\n        try {\r\n            // First clear all existing notifications to avoid duplicates\r\n            const pending = await LocalNotifications.getPending();\r\n            if (pending.notifications.length > 0) {\r\n                await LocalNotifications.cancel(pending);\r\n            }\r\n\r\n            const schedule = [];\r\n            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n            const todayIndex = new Date().getDay();\r\n\r\n            timetable.forEach((item) => {\r\n                if (item.is_completed) return;\r\n\r\n                const [hours, minutes] = item.start_time.split(':').map(Number);\r\n                const itemDayIndex = days.indexOf(item.day);\r\n                const repeatConfig = typeof item.repeat_config === 'string' ? JSON.parse(item.repeat_config) : (item.repeat_config || { type: 'None' });\r\n\r\n                if (itemDayIndex === -1 && repeatConfig.type !== 'Daily') return;\r\n\r\n                const now = new Date();\r\n                let notificationDate = new Date();\r\n                notificationDate.setHours(hours, minutes, 0, 0);\r\n\r\n                // Apply alert offset (e.g. 5 mins before)\r\n                const offsetMinutes = item.alert_offset || 0;\r\n                notificationDate.setMinutes(notificationDate.getMinutes() - offsetMinutes);\r\n\r\n                // Personalize body based on user request: \"pavan its 2pm it's time do dsa\"\r\n                const ampm = hours >= 12 ? 'pm' : 'am';\r\n                const displayHour = hours % 12 || 12;\r\n                const timeString = `${displayHour}${ampm}`;\r\n                const body = `${userName}, it's ${timeString}! It's time to do ${item.subject}.`;\r\n\r\n                if (repeatConfig.type === 'Daily') {\r\n                    // Daily notification\r\n                    if (notificationDate < now) {\r\n                        notificationDate.setDate(notificationDate.getDate() + 1);\r\n                    }\r\n                    schedule.push({\r\n                        title: `⏰ Time for ${item.subject}`,\r\n                        body: body,\r\n                        id: Math.floor(Math.random() * 1000000),\r\n                        schedule: {\r\n                            on: { hour: hours, minute: Math.max(0, minutes - offsetMinutes) },\r\n                            repeats: true,\r\n                            allowWhileIdle: true\r\n                        },\r\n                        sound: 'default',\r\n                        channelId: 'class-reminders',\r\n                        extra: { type: 'class_reminder' }\r\n                    });\r\n                } else {\r\n                    // Weekly or One-time\r\n                    let daysAway = itemDayIndex - todayIndex;\r\n                    if (daysAway < 0) daysAway += 7;\r\n\r\n                    notificationDate.setDate(now.getDate() + daysAway);\r\n                    if (notificationDate < now) {\r\n                        notificationDate.setDate(notificationDate.getDate() + 7);\r\n                    }\r\n\r\n                    schedule.push({\r\n                        title: `⏰ Time for ${item.subject}`,\r\n                        body: body,\r\n                        id: Math.floor(Math.random() * 1000000),\r\n                        schedule: {\r\n                            at: notificationDate,\r\n                            repeats: repeatConfig.type === 'Weekly',\r\n                            every: repeatConfig.type === 'Weekly' ? 'week' : undefined,\r\n                            allowWhileIdle: true\r\n                        },\r\n                        sound: 'default',\r\n                        channelId: 'class-reminders',\r\n                        extra: { type: 'class_reminder' }\r\n                    });\r\n                }\r\n            });\r\n\r\n            if (schedule.length > 0) {\r\n                // Ensure unique IDs\r\n                const uniqueSchedule = schedule.map((s, idx) => ({ ...s, id: idx + 100 }));\r\n                await LocalNotifications.schedule({\r\n                    notifications: uniqueSchedule.slice(0, 50)\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Failed to schedule notifications:', error);\r\n        }\r\n    }\r\n\r\n    async notifyImmediately(title, body) {\r\n        await LocalNotifications.schedule({\r\n            notifications: [\r\n                {\r\n                    title,\r\n                    body,\r\n                    id: 1,\r\n                    schedule: { at: new Date(Date.now() + 1000) },\r\n                    sound: 'default'\r\n                }\r\n            ]\r\n        });\r\n    }\r\n}\r\n\r\nexport default new NotificationService();\r\n"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,gCAAgC;AAEnE,MAAMC,mBAAmB,CAAC;EACtB,MAAMC,kBAAkBA,CAAA,EAAG;IACvB,IAAI;MACA;MACA,MAAMF,kBAAkB,CAACG,aAAa,CAAC;QACnCC,EAAE,EAAE,iBAAiB;QACrBC,IAAI,EAAE,iBAAiB;QACvBC,WAAW,EAAE,oCAAoC;QACjDC,UAAU,EAAE,CAAC;QAAE;QACfC,UAAU,EAAE,CAAC;QACbC,KAAK,EAAE,UAAU;QAAE;QACnBC,SAAS,EAAE;MACf,CAAC,CAAC;MAEF,MAAM;QAAEC;MAAQ,CAAC,GAAG,MAAMX,kBAAkB,CAACE,kBAAkB,CAAC,CAAC;MACjE,OAAOS,OAAO,KAAK,SAAS;IAChC,CAAC,CAAC,OAAOC,CAAC,EAAE;MACRC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEF,CAAC,CAAC;MAC7C,OAAO,KAAK;IAChB;EACJ;EAEA,MAAMG,sBAAsBA,CAACC,SAAS,EAAEC,QAAQ,GAAG,OAAO,EAAE;IACxD,IAAI;MACA;MACA,MAAMC,OAAO,GAAG,MAAMlB,kBAAkB,CAACmB,UAAU,CAAC,CAAC;MACrD,IAAID,OAAO,CAACE,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;QAClC,MAAMrB,kBAAkB,CAACsB,MAAM,CAACJ,OAAO,CAAC;MAC5C;MAEA,MAAMK,QAAQ,GAAG,EAAE;MACnB,MAAMC,IAAI,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,UAAU,CAAC;MAC3F,MAAMC,UAAU,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;MAEtCX,SAAS,CAACY,OAAO,CAAEC,IAAI,IAAK;QACxB,IAAIA,IAAI,CAACC,YAAY,EAAE;QAEvB,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGH,IAAI,CAACI,UAAU,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;QAC/D,MAAMC,YAAY,GAAGb,IAAI,CAACc,OAAO,CAACT,IAAI,CAACU,GAAG,CAAC;QAC3C,MAAMC,YAAY,GAAG,OAAOX,IAAI,CAACY,aAAa,KAAK,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACd,IAAI,CAACY,aAAa,CAAC,GAAIZ,IAAI,CAACY,aAAa,IAAI;UAAEG,IAAI,EAAE;QAAO,CAAE;QAEvI,IAAIP,YAAY,KAAK,CAAC,CAAC,IAAIG,YAAY,CAACI,IAAI,KAAK,OAAO,EAAE;QAE1D,MAAMC,GAAG,GAAG,IAAInB,IAAI,CAAC,CAAC;QACtB,IAAIoB,gBAAgB,GAAG,IAAIpB,IAAI,CAAC,CAAC;QACjCoB,gBAAgB,CAACC,QAAQ,CAAChB,KAAK,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;;QAE/C;QACA,MAAMgB,aAAa,GAAGnB,IAAI,CAACoB,YAAY,IAAI,CAAC;QAC5CH,gBAAgB,CAACI,UAAU,CAACJ,gBAAgB,CAACK,UAAU,CAAC,CAAC,GAAGH,aAAa,CAAC;;QAE1E;QACA,MAAMI,IAAI,GAAGrB,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI;QACtC,MAAMsB,WAAW,GAAGtB,KAAK,GAAG,EAAE,IAAI,EAAE;QACpC,MAAMuB,UAAU,GAAG,GAAGD,WAAW,GAAGD,IAAI,EAAE;QAC1C,MAAMG,IAAI,GAAG,GAAGtC,QAAQ,UAAUqC,UAAU,qBAAqBzB,IAAI,CAAC2B,OAAO,GAAG;QAEhF,IAAIhB,YAAY,CAACI,IAAI,KAAK,OAAO,EAAE;UAC/B;UACA,IAAIE,gBAAgB,GAAGD,GAAG,EAAE;YACxBC,gBAAgB,CAACW,OAAO,CAACX,gBAAgB,CAACY,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;UAC5D;UACAnC,QAAQ,CAACoC,IAAI,CAAC;YACVC,KAAK,EAAE,cAAc/B,IAAI,CAAC2B,OAAO,EAAE;YACnCD,IAAI,EAAEA,IAAI;YACVnD,EAAE,EAAEyD,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC;YACvCxC,QAAQ,EAAE;cACNyC,EAAE,EAAE;gBAAEC,IAAI,EAAElC,KAAK;gBAAEmC,MAAM,EAAEL,IAAI,CAACM,GAAG,CAAC,CAAC,EAAEnC,OAAO,GAAGgB,aAAa;cAAE,CAAC;cACjEoB,OAAO,EAAE,IAAI;cACbC,cAAc,EAAE;YACpB,CAAC;YACD5D,KAAK,EAAE,SAAS;YAChB6D,SAAS,EAAE,iBAAiB;YAC5BC,KAAK,EAAE;cAAE3B,IAAI,EAAE;YAAiB;UACpC,CAAC,CAAC;QACN,CAAC,MAAM;UACH;UACA,IAAI4B,QAAQ,GAAGnC,YAAY,GAAGZ,UAAU;UACxC,IAAI+C,QAAQ,GAAG,CAAC,EAAEA,QAAQ,IAAI,CAAC;UAE/B1B,gBAAgB,CAACW,OAAO,CAACZ,GAAG,CAACa,OAAO,CAAC,CAAC,GAAGc,QAAQ,CAAC;UAClD,IAAI1B,gBAAgB,GAAGD,GAAG,EAAE;YACxBC,gBAAgB,CAACW,OAAO,CAACX,gBAAgB,CAACY,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;UAC5D;UAEAnC,QAAQ,CAACoC,IAAI,CAAC;YACVC,KAAK,EAAE,cAAc/B,IAAI,CAAC2B,OAAO,EAAE;YACnCD,IAAI,EAAEA,IAAI;YACVnD,EAAE,EAAEyD,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC;YACvCxC,QAAQ,EAAE;cACNkD,EAAE,EAAE3B,gBAAgB;cACpBsB,OAAO,EAAE5B,YAAY,CAACI,IAAI,KAAK,QAAQ;cACvC8B,KAAK,EAAElC,YAAY,CAACI,IAAI,KAAK,QAAQ,GAAG,MAAM,GAAG+B,SAAS;cAC1DN,cAAc,EAAE;YACpB,CAAC;YACD5D,KAAK,EAAE,SAAS;YAChB6D,SAAS,EAAE,iBAAiB;YAC5BC,KAAK,EAAE;cAAE3B,IAAI,EAAE;YAAiB;UACpC,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;MAEF,IAAIrB,QAAQ,CAACF,MAAM,GAAG,CAAC,EAAE;QACrB;QACA,MAAMuD,cAAc,GAAGrD,QAAQ,CAACY,GAAG,CAAC,CAAC0C,CAAC,EAAEC,GAAG,MAAM;UAAE,GAAGD,CAAC;UAAEzE,EAAE,EAAE0E,GAAG,GAAG;QAAI,CAAC,CAAC,CAAC;QAC1E,MAAM9E,kBAAkB,CAACuB,QAAQ,CAAC;UAC9BH,aAAa,EAAEwD,cAAc,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE;QAC7C,CAAC,CAAC;MACN;IACJ,CAAC,CAAC,OAAOjE,KAAK,EAAE;MACZD,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IAC7D;EACJ;EAEA,MAAMkE,iBAAiBA,CAACpB,KAAK,EAAEL,IAAI,EAAE;IACjC,MAAMvD,kBAAkB,CAACuB,QAAQ,CAAC;MAC9BH,aAAa,EAAE,CACX;QACIwC,KAAK;QACLL,IAAI;QACJnD,EAAE,EAAE,CAAC;QACLmB,QAAQ,EAAE;UAAEkD,EAAE,EAAE,IAAI/C,IAAI,CAACA,IAAI,CAACmB,GAAG,CAAC,CAAC,GAAG,IAAI;QAAE,CAAC;QAC7CpC,KAAK,EAAE;MACX,CAAC;IAET,CAAC,CAAC;EACN;AACJ;AAEA,eAAe,IAAIR,mBAAmB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}